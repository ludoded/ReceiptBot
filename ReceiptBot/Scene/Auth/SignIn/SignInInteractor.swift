//
//  SignInInteractor.swift
//  ReceiptBot
//
//  Created by Haik Ampardjian on 4/8/17.
//  Copyright (c) 2017 receiptbot. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so you can apply
//  clean architecture to your iOS and Mac projects, see http://clean-swift.com
//

import UIKit

protocol SignInInteractorOutput {
    func presentLogin(response: SignIn.Login.Response)
    func presentCompleteProfile()
    func presentRegister(response: SignIn.Google.Response)
}

class SignInInteractor {
    var output: (SignInInteractorOutput & PasswordRecoveryInteractorOutput)!
    var worker: SignInWorker!
    
    var completeProfileInfo: SignIn.CompleteProfileInfo!

    // MARK: - Business logic
    func tryToLogin(request: SignIn.Login.Request) {
        worker = SignInWorker(email: request.email ?? "",
                              password: request.password ?? "")
        
        worker.tryToLogin { [weak self] (wrapper) in
            DispatchQueue.main.async { self?.passAuthData(data: wrapper) }
        }
    }
    
    func recoveryPassword(request: PasswordRecoveryModel.Request) {
        let passwordWorker = PasswordRecoveryWorker(with: request.email)
        passwordWorker.tryToRecovery { [weak self] (data) in
            DispatchQueue.main.async { self?.passStatus(data: data) }
        }
    }
    
    func tryToSignUp(request: SignIn.Google.Request) {
        let registerWorker = SignUpWorker(email: request.email, password: request.password)
        registerWorker.tryToSignUp { [weak self] (resp) in
            switch resp {
            case .none: DispatchQueue.main.async { self?.passRegister(data: resp) }
            case .value(let data):
                if !data.isVerified || !data.userAlreadyCreated {
                    DispatchQueue.main.async { self?.passCompleteProfile(email: request.email, name: request.name) }
                }
                else if !data.isVerified || data.userAlreadyCreated {
                    DispatchQueue.main.async { self?.passRegister(data: .none(message: "User Already Registered, Please Verify your Email Address")) }
                }
                else if data.isVerified || data.userAlreadyCreated {
                    self?.tryToExternalSignIn(request: request)
                }
                else {
                    DispatchQueue.main.async { self?.passRegister(data: resp) }
                }
            }
        }
    }
    
    func tryToExternalSignIn(request: SignIn.Google.Request) {
        let extWorker = ExternalLoginWorker(email: request.email)
        extWorker.tryToLogin { [weak self] (resp) in
            DispatchQueue.main.async { self?.passAuthData(data: resp) }
        }
    }
    
    /// MARK: passing data
    func passAuthData(data: RebotValueWrapper<AuthResponse>) {
        let response = SignIn.Login.Response(data: data)
        output.presentLogin(response: response)
    }
    
    func passStatus(data: RebotValueWrapper<StatusDetailResponse>) {
        let response = PasswordRecoveryModel.Response(status: data)
        output.presentRecoveredPassword(response: response)
    }
    
    func passRegister(data: RebotValueWrapper<SignUpFirstResponse>) {
        let response = SignIn.Google.Response(data: data)
        output.presentRegister(response: response)
    }
    
    func passCompleteProfile(email: String, name: String) {
        completeProfileInfo = SignIn.CompleteProfileInfo(email: email, name: name)
        output.presentCompleteProfile()
    }
}
