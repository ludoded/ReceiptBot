//
//  DetailInvoiceInteractor.swift
//  ReceiptBot
//
//  Created by Haik Ampardjian on 4/13/17.
//  Copyright (c) 2017 receiptbot. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so you can apply
//  clean architecture to your iOS and Mac projects, see http://clean-swift.com
//

import UIKit

protocol DetailInvoiceInteractorOutput {
    func presentInitialSetup(response: DetailInvoice.Setup.Response)
    func presentSave(response: DetailInvoice.Save.Response)
    func presentReject(response: DetailInvoice.Reject.Response)
}

class DetailInvoiceInteractor {
    var output: DetailInvoiceInteractorOutput!
    
    var originalInvoice: SyncConvertedInvoiceResponse?

    // MARK: - Business logic
    func initialSetup() {
        let response = DetailInvoice.Setup.Response(with: originalInvoice)
        output.presentInitialSetup(response: response)
    }
    
    func save(request: DetailInvoice.Save.Request) {
        guard canPerformAction(for: originalInvoice?.type ?? "") else { self.passSave(data: .none(message: "Can't Update the Invoice because of Status")); return }
        
        let category = request.category ?? ""
        let categoryId = AppSettings.shared.config.categoryId(by: category)
        let supplierName = AppSettings.shared.config.supplierId(by: request.supplierName ?? "")
        let paymentId = AppSettings.shared.config.paymentId(by: request.paymentMethod ?? "")
        let taxId = AppSettings.shared.config.taxId(by: request.taxRate ?? "")
        
        let param = DetailInvoice.Save.Params(status: "Approved",
                                              convertedInvoiceId: originalInvoice?.convertedInvoiceId ?? "0",
                                              dueDate: request.dueDate ?? "",
                                              entityId: originalInvoice?.entityId ?? "",
                                              fileName: originalInvoice?.fileName ?? "",
                                              grossNumber: request.grossAmount ?? "",
                                              invoiceNumber: request.invoiceNumber ?? "",
                                              invoicedateMobile: request.invoiceDate ?? "",
                                              netAmount: request.netAmount ?? "",
                                              originalInvoiceId: originalInvoice?.originalInvoiceId ?? "",
                                              originalFileName: originalInvoice?.originalFileName ?? "",
                                              supplierName: String(supplierName),
                                              taxAmount: request.taxAmount ?? "",
                                              taxPercentage: String(taxId),
                                              paymentMethod: String(paymentId),
                                              categoryId: categoryId)
        
        let worker = DetailInvoiceSaveWorker(params: param.params)
        worker.save { [weak self] (inv) in
            DispatchQueue.main.async { self?.passSave(data: inv) }
        }
    }
    
    func reject(request: DetailInvoice.Reject.Request) {
        guard canPerformAction(for: originalInvoice?.type ?? "") else { self.passReject(data: .none(message: "Can't Reject the Invoice because of Status")); return }
        
        let entityId = AppSettings.shared.user.entityId
        let params = DetailInvoice.Reject.Params(comment: request.comment,
                                                 entityId: entityId,
                                                 invoiceId: originalInvoice?.convertedInvoiceId ?? "",
                                                 originalInvoiceId: originalInvoice?.originalInvoiceId ?? "")
        let worker = DetailInvoiceRejectWorker(request: params)
        worker.reject { [weak self] (data) in
            DispatchQueue.main.async { self?.passReject(data: data) }
        }
    }
    
    func validate(invoiceDateString: String, dueDateString: String) -> Bool {
        guard let invoiceDate = DateFormatters.mdySpaceFormatter.date(from: invoiceDateString),
            let dueDate = DateFormatters.mdySpaceFormatter.date(from: dueDateString)
            else { return false }
        return invoiceDate.compare(dueDate) != .orderedDescending
    }
    
    func passSave(data: RebotValueWrapper<SyncConvertedInvoiceResponse>) {
        let response = DetailInvoice.Save.Response(data: data)
        output.presentSave(response: response)
    }
    
    func passReject(data: RebotValueWrapper<SyncConvertedInvoiceResponse>) {
        let response = DetailInvoice.Reject.Response(data: data)
        output.presentReject(response: response)
    }
    
    fileprivate func canPerformAction(for type: String) -> Bool {
        let frontEndType = RebotInvoiceStatusMapper.toFrontEnd(from: type)
        return frontEndType == "Approved" || frontEndType == "Processed"
    }
}
